<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>藍氏象棋</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js 用於音效 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <!-- Supabase 用於資料庫 -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --board-bg: #d8c3a5;
            --board-border: #8e795e;
            --piece-bg: #f9f6f2;
            --piece-shadow: rgba(0,0,0,0.3);
            --red-text: #c84b31;
            --black-text: #2d2d2d;
            --selected-glow: #f7b733;
            --hint-color: rgba(10, 132, 38, 0.5);
            --font-family-status: 'Noto Serif TC', serif;
            --font-family-piece: 'Ma Shan Zheng', cursive;
        }

        body {
            font-family: var(--font-family-status);
            background-color: #f0e9dc; /* Light yellow background */
            /* Removed background-image */
            overflow-y: auto;
        }

        .hidden {
            display: none !important;
        }

        /* 主選單樣式 */
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.7);
        }
        #main-menu h1 {
            font-family: var(--font-family-piece);
            font-size: clamp(4rem, 10vw, 6rem);
            margin-bottom: 1rem;
            color: #f0e9dc;
        }
        #main-menu p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
        }
        .difficulty-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .difficulty-btn {
            background-color: var(--board-border);
            color: var(--piece-bg);
            border: 3px solid var(--piece-bg);
            padding: 1rem 2rem;
            border-radius: 15px;
            font-size: 1.5rem;
            font-family: var(--font-family-status);
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }
        .difficulty-btn:hover {
            background-color: #7a684e;
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .game-wrapper {
            background-color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            padding: 1rem;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 100vh;
        }

        .game-container {
            width: 100%;
            max-width: 700px;
            margin: 2rem auto; 
            padding: 1.5rem;
            background-color: var(--board-bg);
            background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
            border-radius: 15px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.25), 0 5px 10px rgba(0,0,0,0.15);
            border: 8px solid var(--board-border);
        }
        
        #game-board {
            position: relative;
            background-image: url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' viewBox='0 0 80 90' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cstyle%3E.river-text %7B font-size: 8px; font-family: 'Ma Shan Zheng', cursive; fill: %238e795e; %7D%3C/style%3E%3C/defs%3E%3C!-- Vertical Lines --%3E%3Cpath d='M0 0 V40 M0 50 V90 M10 0 V40 M10 50 V90 M20 0 V40 M20 50 V90 M30 0 V40 M30 50 V90 M40 0 V40 M40 50 V90 M50 0 V40 M50 50 V90 M60 0 V40 M60 50 V90 M70 0 V40 M70 50 V90 M80 0 V40 M80 50 V90' stroke='%238e795e' stroke-width='0.5'/%3E%3C!-- Horizontal Lines --%3E%3Cpath d='M0 0 H80 M0 10 H80 M0 20 H80 M0 30 H80 M0 40 H80 M0 50 H80 M0 60 H80 M0 70 H80 M0 80 H80 M0 90 H80' stroke='%238e795e' stroke-width='0.5'/%3E%3C!-- Palaces --%3E%3Cpath d='M30 0 L50 20 M50 0 L30 20 M30 70 L50 90 M50 70 L30 90' stroke='%238e795e' stroke-width='0.5'/%3E%3C!-- River --%3E%3Ctext x='7' y='48' class='river-text'%3E楚 河%3C/text%3E%3Ctext x='47' y='48' class='river-text'%3E漢 界%3C/text%3E%3C/svg%3E");
            background-size: 100% 100%;
            background-repeat: no-repeat;
            background-position: center;
            aspect-ratio: 9/10;
        }

        .piece {
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1.6rem, 3.5vw, 2.0rem);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            position: absolute;
            background-color: var(--piece-bg);
            box-shadow: inset 0 -3px 5px rgba(0,0,0,0.1), 0 5px 10px var(--piece-shadow);
            border: 3px solid var(--board-border);
            z-index: 10;
            transform: translate(-50%, -50%);
        }
        
        .piece.red-piece {
            color: var(--red-text);
            border: 3px solid var(--red-text);
            text-shadow: 0 0 5px rgba(200, 75, 49, 0.5);
        }

        .piece.black-piece {
            color: var(--black-text);
            border: 3px solid var(--black-text);
            text-shadow: 0 0 5px rgba(45, 45, 45, 0.3);
        }
        
        .piece.selected {
            box-shadow: 0 0 25px 8px var(--selected-glow), inset 0 -3px 5px rgba(0,0,0,0.1);
            z-index: 20;
        }

        .piece.ai-last-move {
            animation: blink-animation 1.5s infinite;
            z-index: 15;
        }

        @keyframes blink-animation {
            0%, 100% { 
                box-shadow: 0 0 25px 8px var(--selected-glow), inset 0 -3px 5px rgba(0,0,0,0.1); 
                opacity: 1;
            }
            50% { 
                box-shadow: inset 0 -3px 5px rgba(0,0,0,0.1), 0 5px 10px var(--piece-shadow);
                opacity: 0.6;
            }
        }

        .hint {
            position: absolute;
            background-color: var(--hint-color);
            border-radius: 50%;
            z-index: 5;
            animation: pulse 1.5s infinite;
            transform: translate(-50%, -50%);
        }

        @keyframes pulse {
            0% { opacity: 0.7; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0.7; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        #game-status {
            font-family: var(--font-family-status);
            font-size: 1.25rem;
            font-weight: 600;
            text-align: center;
            padding: 1rem;
            min-height: 70px;
            color: var(--black-text);
            background-color: rgba(255,255,255,0.6);
            border-radius: 10px;
            margin-bottom: 1rem;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }
        
        .game-controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap; /* 允許換行 */
            gap: 1rem;
            margin-top: 2.5rem; 
        }

        .control-button {
            background-color: var(--board-border);
            color: var(--piece-bg);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            font-size: 1.1rem;
            font-family: var(--font-family-status);
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px var(--piece-shadow);
        }

        .control-button:hover:not(:disabled) {
            background-color: #7a684e;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px var(--piece-shadow);
        }
        
        .control-button:disabled {
            background-color: #b0a390;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Modal Base Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }
        .modal.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-box {
            padding: 2rem 3rem;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transform: scale(0.7);
            transition: transform 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            position: relative;
            overflow: hidden;
            max-width: 90%;
            width: 500px; /* 加寬以容納表格 */
        }
        .modal.show .modal-box {
            transform: scale(1);
        }
        .modal-box h2 {
            font-family: var(--font-family-piece);
            font-size: 3.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        .modal-box p {
            font-size: 1.2rem;
            margin-bottom: 1.5rem;
        }
        .modal-box .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .modal-box button {
            padding: 0.5rem 1.5rem;
            border-radius: 8px;
            border: none;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .modal-box .confirm-yes {
            background-color: var(--red-text);
            color: white;
        }
        .modal-box .confirm-yes:hover {
            background-color: #a53c27;
        }
        .modal-box .confirm-no, .modal-box .close-btn {
            background-color: #ccc;
            color: #333;
        }
        .modal-box .confirm-no:hover, .modal-box .close-btn:hover {
            background-color: #bbb;
        }
        
        #victory-modal .modal-box {
             background: linear-gradient(135deg, #fdfcfb, #e2d1c3);
             color: var(--board-border);
        }
        .confetti {
            position: absolute;
            width: 10px;
            height: 20px;
            background-color: #f00;
            top: -50px;
            opacity: 0;
            animation: fall 5s linear infinite;
        }
        @keyframes fall {
            to {
                transform: translateY(120vh) rotate(360deg);
                opacity: 1;
            }
        }
        
        #defeat-modal .modal-box {
            background: linear-gradient(135deg, #6c757d, #495057);
            color: #f8f9fa;
        }
        .leaf {
            position: absolute;
            width: 20px;
            height: 10px;
            background-color: #a0a0a0;
            opacity: 0.5;
            border-radius: 10px 0;
            top: -20px;
            animation: blow-wind 4s linear infinite;
        }
        @keyframes blow-wind {
          0% { transform: translateX(-50px) rotate(0deg); opacity: 0; }
          20% { opacity: 0.7; }
          100% { transform: translateX(300px) translateY(150px) rotate(720deg); opacity: 0; }
        }

        #confirm-modal .modal-box, #undo-modal .modal-box, #restart-confirm-modal .modal-box, #back-to-menu-confirm-modal .modal-box {
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0);
            color: #333;
        }
        
        /* 新增：遊戲紀錄 Modal 樣式 */
        #history-modal .modal-box {
            background: linear-gradient(135deg, #e8e8e8, #f8f8f8);
            color: #333;
            text-align: left;
        }
        #history-modal h2 {
            text-align: center;
            font-size: 2.5rem;
        }
        #history-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: rgba(0,0,0,0.05);
            border-radius: 10px;
        }
        #history-stats div {
            text-align: center;
        }
        #history-stats .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--board-border);
        }
        #history-stats .stat-label {
            font-size: 0.9rem;
            color: #666;
        }
        #history-table-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        #history-table {
            width: 100%;
            border-collapse: collapse;
        }
        #history-table th, #history-table td {
            padding: 0.75rem;
            text-align: center;
            border-bottom: 1px solid #ddd;
        }
        #history-table th {
            background-color: #f0f0f0;
            position: sticky;
            top: 0;
        }
        #history-table tr:last-child td {
            border-bottom: none;
        }
        #history-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .result-win { color: #28a745; font-weight: bold; }
        .result-loss { color: #dc3545; font-weight: bold; }
        .result-draw { color: #6c757d; font-weight: bold; }

    </style>
</head>
<body>

    <!-- 主選單 -->
    <div id="main-menu">
        <h1>藍氏象棋</h1>
        <p>請選擇挑戰難度</p>
        <div class="difficulty-buttons">
            <button class="difficulty-btn" data-difficulty="intermediate">挑戰中手</button>
            <button class="difficulty-btn" data-difficulty="expert">挑戰高手</button>
            <button class="difficulty-btn" data-difficulty="grandmaster">挑戰宗師</button> <!-- 新增宗師難度 -->
        </div>
    </div>

    <!-- 遊戲主體 (預設隱藏) -->
    <div class="game-wrapper hidden">
        <div class="game-container">
            <div id="game-status"></div>
            <div id="game-board"></div>
            <div class="game-controls">
                <button id="undo-button" class="control-button">悔棋</button>
                <button id="restart-button" class="control-button">重新開始</button>
                <button id="history-button" class="control-button">遊戲紀錄</button>
                <button id="back-to-menu-btn" class="control-button">回主畫面</button>
            </div>
        </div>
    </div>

    <!-- 各式彈出視窗 -->
    <div id="victory-modal" class="modal">
        <div class="modal-box">
            <h2>大獲全勝！</h2>
            <p>您已成功擊敗對手！</p>
        </div>
    </div>

    <div id="defeat-modal" class="modal">
        <div class="modal-box">
            <h2>再接再厲！</h2>
            <p>失敗乃成功之母，整理旗鼓，再挑戰一局！</p>
        </div>
    </div>

    <div id="confirm-modal" class="modal">
        <div class="modal-box">
            <h2>三思而後行</h2>
            <p>此步兇險，將(帥)有被吃之虞，是否確定要走？</p>
            <div class="modal-buttons">
                <button id="confirm-yes-btn" class="confirm-yes">確定</button>
                <button id="confirm-no-btn" class="confirm-no">取消</button>
            </div>
        </div>
    </div>
    
    <div id="undo-modal" class="modal">
        <div class="modal-box">
            <h2>大丈夫，能屈能伸</h2>
            <p id="undo-message">一著不慎，滿盤皆輸。真的要收回這一步嗎？</p>
            <div class="modal-buttons">
                <button id="undo-yes-btn" class="confirm-yes">時光倒流</button>
                <button id="undo-no-btn" class="confirm-no">我再想想</button>
            </div>
        </div>
    </div>

    <div id="restart-confirm-modal" class="modal">
        <div class="modal-box">
            <h2>重新開始？</h2>
            <p>確定要放棄目前的對局，重新開始一盤嗎？</p>
            <div class="modal-buttons">
                <button id="restart-yes-btn" class="confirm-yes">確定</button>
                <button id="restart-no-btn" class="confirm-no">取消</button>
            </div>
        </div>
    </div>
    
    <div id="back-to-menu-confirm-modal" class="modal">
        <div class="modal-box">
            <h2>返回主選單？</h2>
            <p>目前的遊戲進度將會遺失，確定要返回嗎？</p>
            <div class="modal-buttons">
                <button id="back-to-menu-yes-btn" class="confirm-yes">確定</button>
                <button id="back-to-menu-no-btn" class="confirm-no">取消</button>
            </div>
        </div>
    </div>
    
    <!-- 新增：遊戲紀錄 Modal -->
    <div id="history-modal" class="modal">
        <div class="modal-box">
            <h2>遊戲紀錄</h2>
            <div id="history-stats">
                <!-- 統計數據將由 JS 動態填入 -->
            </div>
            <div id="history-table-container">
                <table id="history-table">
                    <thead>
                        <tr>
                            <th>日期</th>
                            <th>難度</th>
                            <th>結果</th>
                        </tr>
                    </thead>
                    <tbody id="history-table-body">
                        <!-- 歷史紀錄將由 JS 動態填入 -->
                    </tbody>
                </table>
            </div>
             <div id="history-error" class="text-red-500 mt-4 text-center hidden"></div>
            <div class="modal-buttons">
                <button id="history-close-btn" class="close-btn">關閉</button>
            </div>
        </div>
    </div>


    <script>
        // --- Supabase 設定 ---
        // 請將 'YOUR_SUPABASE_URL' 和 'YOUR_SUPABASE_ANON_KEY' 替換成您自己的 Supabase 專案資訊
        const SUPABASE_URL = 'https://vqaqiwfkwtgkbcccmhag.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZxYXFpd2Zrd3Rna2JjY2NtaGFnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI3MTYwNTYsImV4cCI6MjA2ODI5MjA1Nn0.swbrvzUL0VxumglJO0153qAK7A_VM-Gx6j6X7TZ51Do';
        let supabase = null;
        let userId = 'default-user'; // 在真實應用中，這應該是登入後的使用者ID

        try {
            if (SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_KEY !== 'YOUR_SUPABASE_ANON_KEY') {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                console.log('Supabase 連線成功');
            } else {
                 console.warn('Supabase URL 或 Key 未設定，遊戲紀錄功能將無法使用。');
            }
        } catch (error) {
            console.error('Supabase 初始化失敗:', error);
        }

        // --- DOM 元素 ---
        const mainMenu = document.getElementById('main-menu');
        const gameWrapper = document.querySelector('.game-wrapper');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');
        const boardEl = document.getElementById('game-board');
        const statusEl = document.getElementById('game-status');
        const restartBtn = document.getElementById('restart-button');
        const undoBtn = document.getElementById('undo-button');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');
        const historyBtn = document.getElementById('history-button');
        
        // --- 彈出視窗 ---
        const victoryModal = document.getElementById('victory-modal');
        const defeatModal = document.getElementById('defeat-modal');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmYesBtn = document.getElementById('confirm-yes-btn');
        const confirmNoBtn = document.getElementById('confirm-no-btn');
        const undoModal = document.getElementById('undo-modal');
        const undoMessageEl = document.getElementById('undo-message');
        const undoYesBtn = document.getElementById('undo-yes-btn');
        const undoNoBtn = document.getElementById('undo-no-btn');
        const restartConfirmModal = document.getElementById('restart-confirm-modal');
        const restartYesBtn = document.getElementById('restart-yes-btn');
        const restartNoBtn = document.getElementById('restart-no-btn');
        const backToMenuConfirmModal = document.getElementById('back-to-menu-confirm-modal');
        const backToMenuYesBtn = document.getElementById('back-to-menu-yes-btn');
        const backToMenuNoBtn = document.getElementById('back-to-menu-no-btn');
        const historyModal = document.getElementById('history-modal');
        const historyCloseBtn = document.getElementById('history-close-btn');
        const historyStatsEl = document.getElementById('history-stats');
        const historyTableBodyEl = document.getElementById('history-table-body');
        const historyErrorEl = document.getElementById('history-error');

        // --- 遊戲常數 ---
        const BOARD_COLS = 9;
        const BOARD_ROWS = 10;
        const MAX_UNDO_COUNT = 3;

        // --- AI 相關常數 ---
        let AI_CURRENT_SEARCH_DEPTH = 2; // 預設中手難度
        const AI_TIME_LIMIT_MS = 4500; // 4.5 秒，確保在 5 秒內響應

        // --- 棋子設定 ---
        const PIECE_CONFIG = {
            'k': { name: '將', color: 'black' }, 'g': { name: '帥', color: 'red' },
            'a': { name: '士', color: 'black' }, 'd': { name: '仕', color: 'red' },
            'e': { name: '象', color: 'black' }, 'h': { name: '相', color: 'red' },
            'r': { name: '車', color: 'black' }, 't': { name: '俥', color: 'red' },
            'n': { name: '馬', color: 'black' }, 'm': { name: '傌', color: 'red' },
            'c': { name: '炮', color: 'black' }, 'x': { name: '砲', color: 'red' },
            'p': { name: '卒', color: 'black' }, 's': { name: '兵', color: 'red' }
        };
        const pieceValues = { '帥': 10000, '將': 10000, '仕': 120, '士': 120, '相': 120, '象': 120, '俥': 500, '車': 500, '傌': 300, '馬': 300, '砲': 320, '炮': 320, '兵': 80, '卒': 80 };

        const initialBoardSetup = [
            "r", "n", "e", "a", "k", "a", "e", "n", "r",
            "",  "",  "",  "",  "",  "",  "",  "",  "",
            "", "c",  "",  "",  "",  "",  "", "c",  "",
            "p", "", "p",  "", "p",  "", "p",  "", "p",
            "",  "",  "",  "",  "",  "",  "",  "",  "",
            "",  "",  "",  "",  "",  "",  "",  "",  "",
            "s", "", "s",  "", "s",  "", "s",  "", "s",
            "", "x",  "",  "",  "",  "",  "", "x",  "",
            "",  "",  "",  "",  "",  "",  "",  "",  "",
            "t", "m", "h", "d", "g", "d", "h", "m", "t",
        ];
        
        // --- 遊戲狀態變數 ---
        let boardState = [];
        let playerColor = 'red';
        let aiColor = 'black';
        let currentPlayer = 'red';
        let selectedPiece = null;
        let gameOver = false;
        let isPlayerTurn = true;
        let pendingMove = null;
        let moveHistory = [];
        let undoCount = MAX_UNDO_COUNT;
        let aiLastMove = null;
        let aiThinkingInterval = null;
        let aiDifficulty = 'intermediate'; // 儲存當前難度
        let searchStartTime = 0; // 用於時間限制搜索

        // --- 音效 ---
        let moveSound, captureSound;
        
        // --- AI 強化：棋子位置價值表 (Piece-Square Tables) ---
        // 這些值可以根據實際測試進行調整，以優化AI表現
        // Values are for Red pieces. Black pieces will use reversed tables.
        const PST_GENERAL_RED = [ // 帥/將
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  10, 15, 10,  0,  0,  0],
            [  0,  0,  0,  20, 25, 20,  0,  0,  0],
            [  0,  0,  0,  10, 15, 10,  0,  0,  0]
        ];

        const PST_ADVISOR_RED = [ // 仕/士
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  10, 20, 10,  0,  0,  0],
            [  0,  0,  0,  0,  10,  0,  0,  0,  0]
        ];

        const PST_ELEPHANT_RED = [ // 相/象
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  10, 0,  0,  0, 10,  0,  0],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0],
            [  0,  0,  20, 0,  0,  0, 20,  0,  0]
        ];

        const PST_ROOK_RED = [ // 車/俥
            [ 90, 90, 90, 90, 90, 90, 90, 90, 90],
            [ 80, 80, 80, 80, 80, 80, 80, 80, 80],
            [ 70, 70, 70, 70, 70, 70, 70, 70, 70],
            [ 60, 60, 60, 60, 60, 60, 60, 60, 60],
            [ 50, 50, 50, 50, 50, 50, 50, 50, 50],
            [ 40, 40, 40, 40, 40, 40, 40, 40, 40],
            [ 30, 30, 30, 30, 30, 30, 30, 30, 30],
            [ 20, 20, 20, 20, 20, 20, 20, 20, 20],
            [ 10, 10, 10, 10, 10, 10, 10, 10, 10],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0]
        ];

        const PST_HORSE_RED = [ // 馬/傌
            [ 90, 90, 90, 90, 90, 90, 90, 90, 90],
            [ 80, 80, 80, 80, 80, 80, 80, 80, 80],
            [ 70, 70, 70, 70, 70, 70, 70, 70, 70],
            [ 60, 60, 60, 60, 60, 60, 60, 60, 60],
            [ 50, 50, 50, 50, 50, 50, 50, 50, 50],
            [ 40, 40, 40, 40, 40, 40, 40, 40, 40],
            [ 30, 30, 30, 30, 30, 30, 30, 30, 30],
            [ 20, 20, 20, 20, 20, 20, 20, 20, 20],
            [ 10, 10, 10, 10, 10, 10, 10, 10, 10],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0]
        ];

        const PST_CANNON_RED = [ // 炮/砲
            [ 90, 90, 90, 90, 90, 90, 90, 90, 90],
            [ 80, 80, 80, 80, 80, 80, 80, 80, 80],
            [ 70, 70, 70, 70, 70, 70, 70, 70, 70],
            [ 60, 60, 60, 60, 60, 60, 60, 60, 60],
            [ 50, 50, 50, 50, 50, 50, 50, 50, 50],
            [ 40, 40, 40, 40, 40, 40, 40, 40, 40],
            [ 30, 30, 30, 30, 30, 30, 30, 30, 30],
            [ 20, 20, 20, 20, 20, 20, 20, 20, 20],
            [ 10, 10, 10, 10, 10, 10, 10, 10, 10],
            [  0,  0,  0,  0,  0,  0,  0,  0,  0]
        ];

        const PST_PAWN_RED = [ // 兵/卒 (already good, slightly adjusted for consistency)
            [ 9,  9,  9, 11, 13, 11,  9,  9,  9],
            [19, 21, 23, 25, 26, 25, 23, 21, 19],
            [19, 21, 23, 25, 26, 25, 23, 21, 19],
            [14, 16, 18, 20, 21, 20, 18, 16, 14],
            [ 7,  9, 11, 12, 13, 12, 11,  9,  7],
            [ 0,  0,  0,  0,  0,  0,  0,  0,  0],
            [ 0,  0,  0,  0,  0,  0,  0,  0,  0],
            [ 0,  0,  0,  0,  0,  0,  0,  0,  0],
            [ 0,  0,  0,  0,  0,  0,  0,  0,  0],
            [ 0,  0,  0,  0,  0,  0,  0,  0,  0]
        ];

        // Black PSTs are simply reversed Red PSTs
        const PST_GENERAL_BLACK = [...PST_GENERAL_RED].reverse();
        const PST_ADVISOR_BLACK = [...PST_ADVISOR_RED].reverse();
        const PST_ELEPHANT_BLACK = [...PST_ELEPHANT_RED].reverse();
        const PST_ROOK_BLACK = [...PST_ROOK_RED].reverse();
        const PST_HORSE_BLACK = [...PST_HORSE_RED].reverse();
        const PST_CANNON_BLACK = [...PST_CANNON_RED].reverse();
        const PST_PAWN_BLACK = [...PST_PAWN_RED].reverse();
        
        function setupSounds() {
            if (typeof Tone === 'undefined') return;
            moveSound = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).toDestination();
            captureSound = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' } }).toDestination();
        }

        function playSound(type) {
             if (typeof Tone === 'undefined' || Tone.context.state !== 'running') return;
            try {
                if (type === 'move') moveSound.triggerAttackRelease('0.1');
                if (type === 'capture') captureSound.triggerAttackRelease('C3', '8n');
            } catch (e) { console.error("音效播放失敗:", e); }
        }

        function initGame() {
            if (aiThinkingInterval) clearInterval(aiThinkingInterval);
            aiThinkingInterval = null;
            gameOver = false;
            currentPlayer = 'red';
            selectedPiece = null;
            isPlayerTurn = true;
            pendingMove = null;
            moveHistory = [];
            undoCount = MAX_UNDO_COUNT;
            aiLastMove = null;
            
            statusEl.textContent = '歡迎來到藍氏象棋！紅方先行。';
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('show'));
            
            boardState = Array(BOARD_ROWS).fill(null).map(() => Array(BOARD_COLS).fill(null));
            initialBoardSetup.forEach((key, index) => {
                if (key) {
                    const row = Math.floor(index / BOARD_COLS);
                    const col = index % BOARD_COLS;
                    boardState[row][col] = { ...PIECE_CONFIG[key], x: col, y: row };
                }
            });
            updateUndoButton();
            renderBoard();
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            const rect = boardEl.getBoundingClientRect();
            const cellWidth = rect.width / (BOARD_COLS - 1);
            const cellHeight = rect.height / (BOARD_ROWS - 1);
            const pieceSize = Math.min(cellWidth, cellHeight) * 0.95;

            for (let y = 0; y < BOARD_ROWS; y++) {
                // Defensive check: ensure boardState[y] is an array
                if (!Array.isArray(boardState[y])) {
                    console.error(`Error: boardState[${y}] is not an array. Current boardState:`, boardState);
                    // Attempt to re-initialize this row to prevent further errors
                    boardState[y] = Array(BOARD_COLS).fill(null);
                    // Continue to the next iteration to re-render board with fixed row
                    continue; 
                }

                for (let x = 0; x < BOARD_COLS; x++) {
                    const pieceData = boardState[y][x];
                    if (pieceData) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = `piece ${pieceData.color}-piece`;
                        pieceEl.textContent = pieceData.name;
                        
                        pieceEl.style.width = `${pieceSize}px`;
                        pieceEl.style.height = `${pieceSize}px`;
                        
                        const left = x * cellWidth;
                        const top = y * cellHeight;
                        
                        pieceEl.style.left = `${left}px`;
                        pieceEl.style.top = `${top}px`;
                        
                        pieceEl.dataset.x = x;
                        pieceEl.dataset.y = y;

                        if (selectedPiece && selectedPiece.x === x && selectedPiece.y === y) {
                            pieceEl.classList.add('selected');
                            pieceEl.style.transform = 'translate(-50%, -50%) scale(1.08)';
                        } else if (aiLastMove && aiLastMove.x === x && aiLastMove.y === y) {
                            pieceEl.classList.add('ai-last-move');
                        }
                        boardEl.appendChild(pieceEl);
                    }
                }
            }
        }
        
        function clearHighlights() {
            document.querySelectorAll('.hint').forEach(el => el.remove());
        }

        function highlightMoves(moves) {
            clearHighlights();
            const rect = boardEl.getBoundingClientRect();
            const cellWidth = rect.width / (BOARD_COLS - 1);
            const cellHeight = rect.height / (BOARD_ROWS - 1);
            const pieceSize = Math.min(cellWidth, cellHeight) * 0.95;
            const hintSize = pieceSize * 0.4;

            moves.forEach(move => {
                const hintEl = document.createElement('div');
                hintEl.className = 'hint';
                hintEl.style.width = `${hintSize}px`;
                hintEl.style.height = `${hintSize}px`;

                const left = move.toX * cellWidth;
                const top = move.toY * cellHeight;
                hintEl.style.left = `${left}px`;
                hintEl.style.top = `${top}px`;

                hintEl.dataset.x = move.toX;
                hintEl.dataset.y = move.toY;
                boardEl.appendChild(hintEl);
            });
        }

        function handleBoardClick(e) {
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                Tone.start();
            }
            if (gameOver || !isPlayerTurn) return;
            
            const rect = boardEl.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const x = Math.round(clickX / (rect.width / (BOARD_COLS - 1)));
            const y = Math.round(clickY / (rect.height / (BOARD_ROWS - 1)));

            if (x < 0 || x >= BOARD_COLS || y < 0 || y >= BOARD_ROWS) return;

            if (selectedPiece) {
                const isPhysicalMove = getPhysicalMoves(selectedPiece, boardState).some(m => m.toX === x && m.toY === y);
                if (isPhysicalMove) {
                    if (isLosingMove(selectedPiece, x, y)) {
                        pendingMove = { piece: selectedPiece, toX: x, toY: y };
                        confirmModal.classList.add('show');
                    } else {
                        movePiece(selectedPiece, x, y);
                    }
                } else {
                    selectedPiece = null;
                    const newClickedPiece = boardState[y]?.[x];
                    if (newClickedPiece && newClickedPiece.color === currentPlayer) {
                        selectPiece(newClickedPiece);
                    } else {
                        aiLastMove = null;
                        renderBoard();
                        clearHighlights();
                    }
                }
            } else {
                const clickedPiece = boardState[y]?.[x];
                if (clickedPiece && clickedPiece.color === currentPlayer) {
                    selectPiece(clickedPiece);
                }
            }
        }
        
        function selectPiece(piece) {
            aiLastMove = null;
            selectedPiece = piece;
            renderBoard();
            const moves = getLegalMoves(selectedPiece, boardState); // Use getLegalMoves here
            highlightMoves(moves);
        }
        
        function movePiece(piece, toX, toY) {
            if (isPlayerTurn) {
                moveHistory.push(JSON.parse(JSON.stringify(boardState)));
            }
            performMove(piece, toX, toY, boardState, false);
            selectedPiece = null;
            clearHighlights();
            renderBoard();
            if (checkEndGame()) return;
            switchPlayer();
            if(!gameOver && currentPlayer === aiColor) triggerAIMove();
        }

        function performMove(piece, toX, toY, currentBoard, isSimulation = false) {
            const fromX = piece.x;
            const fromY = piece.y;
            const targetPiece = currentBoard[toY][toX];
            if (!isSimulation) {
                if (targetPiece) { playSound('capture'); } 
                else { playSound('move'); }
            }
            
            // *** CRITICAL FIX: Update the piece's own x and y properties directly ***
            // This ensures that the piece object itself always holds its current coordinates.
            // This is vital because the same 'piece' object reference is passed around
            // and its x, y properties are used to locate it on the board.
            piece.x = toX;
            piece.y = toY;

            currentBoard[toY][toX] = piece; // Place the actual piece object
            currentBoard[fromY][fromX] = null; // Clear the original position
        }
        
        function switchPlayer() {
            currentPlayer = (currentPlayer === 'red') ? 'black' : 'red';
            isPlayerTurn = (currentPlayer === playerColor);
            updateStatus();
            updateUndoButton();
        }
        
        function updateStatus() {
            if (gameOver) return;
            if (isPlayerTurn) {
                statusEl.textContent = `輪到您 (紅方) 行動`;
                if (isKingInCheck(playerColor, boardState)) {
                    statusEl.textContent += " (將軍！)";
                }
            } else {
                statusEl.textContent = `輪到 AI (黑方) 思考中...`;
            }
        }
        
        function updateUndoButton() {
            undoBtn.textContent = `悔棋 (${undoCount})`;
            undoBtn.disabled = !(isPlayerTurn && undoCount > 0 && moveHistory.length > 0);
        }

        function handleUndo() {
            const taunts = [
                "大丈夫，能屈能伸。真的要收回這一步嗎？",
                "棋，是這麼下的嗎？確定要悔棋？",
                "哎呀，是不是手滑了？給你個機會反悔。",
                "觀棋不語真君子，落子無悔大丈夫。你確定？",
                "嗯？想耍賴？好吧，就這一次喔！"
            ];
            undoMessageEl.textContent = taunts[Math.floor(Math.random() * taunts.length)];
            undoModal.classList.add('show');
        }

        function executeUndo() {
            if (undoCount <= 0 || moveHistory.length === 0) return;
            undoCount--;
            boardState = moveHistory.pop();
            gameOver = false;
            currentPlayer = playerColor;
            isPlayerTurn = true;
            selectedPiece = null;
            pendingMove = null;
            aiLastMove = null;
            clearHighlights();
            renderBoard();
            updateStatus();
            updateUndoButton();
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('show'));
        }

        // --- 象棋規則 ---
        function isValidMove(piece, toX, toY, board) {
            const target = board[toY][toX];
            if (target && target.color === piece.color) return false;
            const { name, x: fromX, y: fromY } = piece; // piece.x and piece.y are the current position
            const dx = toX - fromX;
            const dy = toY - fromY;
            switch (name) {
                case '帥': case '將':
                    // Flying General rule
                    if (target && (target.name === '將' || target.name === '帥') && target.color !== piece.color) {
                        if (dx === 0 && getPiecesBetween(piece, target, board).length === 0) return true;
                    }
                    if (Math.abs(dx) + Math.abs(dy) !== 1) return false; // Must move one step orthogonally
                    if (toX < 3 || toX > 5) return false; // Must stay within palace columns
                    if (piece.color === 'red' && toY < 7) return false; // Red General must stay in bottom palace rows
                    if (piece.color === 'black' && toY > 2) return false; // Black General must stay in top palace rows
                    return true;
                case '仕': case '士':
                    if (Math.abs(dx) !== 1 || Math.abs(dy) !== 1) return false; // Must move one step diagonally
                    if (toX < 3 || toX > 5) return false; // Must stay within palace columns
                    if (piece.color === 'red' && toY < 7) return false; // Red Advisor must stay in bottom palace rows
                    if (piece.color === 'black' && toY > 2) return false; // Black Advisor must stay in top palace rows
                    return true;
                case '相': case '象':
                    if (Math.abs(dx) !== 2 || Math.abs(dy) !== 2) return false; // Must move two steps diagonally
                    if (piece.color === 'red' && toY < 5) return false; // Red Elephant cannot cross river
                    if (piece.color === 'black' && toY > 4) return false; // Black Elephant cannot cross river
                    if (board[fromY + dy / 2][fromX + dx / 2]) return false; // Blocked by middle piece
                    return true;
                case '俥': case '車':
                    if (dx !== 0 && dy !== 0) return false; // Must move orthogonally
                    return getPiecesBetween(piece, {x: toX, y: toY}, board).length === 0; // No pieces in between
                case '傌': case '馬':
                    if (!((Math.abs(dx) === 1 && Math.abs(dy) === 2) || (Math.abs(dx) === 2 && Math.abs(dy) === 1))) return false; // Horse move pattern
                    if (Math.abs(dx) === 2 && board[fromY][fromX + dx / 2]) return false; // Blocked by horse leg (horizontal)
                    if (Math.abs(dy) === 2 && board[fromY + dy / 2][fromX]) return false; // Blocked by horse leg (vertical)
                    return true;
                case '砲': case '炮':
                    if (dx !== 0 && dy !== 0) return false; // Must move orthogonally
                    const piecesBetween = getPiecesBetween(piece, {x: toX, y: toY}, board);
                    return target ? piecesBetween.length === 1 : piecesBetween.length === 0; // Captures require one piece in between, empty squares require none
                case '兵': // Red Pawn/Soldier
                    return (fromY > 4 && dx === 0 && dy === -1) || // Before river: only forward
                           (fromY <= 4 && ( (dx === 0 && dy === -1) || (Math.abs(dx) === 1 && dy === 0) )); // After river: forward or sideways
                case '卒': // Black Pawn/Soldier
                     return (fromY < 5 && dx === 0 && dy === 1) || // Before river: only forward
                            (fromY >= 5 && ( (dx === 0 && dy === 1) || (Math.abs(dx) === 1 && dy === 0) )); // After river: forward or sideways
            }
            return false;
        }
        
        function getPiecesBetween(p1, p2, board) {
            const pieces = [];
            if (p1.x === p2.x) { // Vertical move
                const startY = Math.min(p1.y, p2.y);
                const endY = Math.max(p1.y, p2.y);
                for (let y = startY + 1; y < endY; y++) {
                    if (board[y][p1.x]) pieces.push(board[y][p1.x]);
                }
            } else if (p1.y === p2.y) { // Horizontal move
                const startX = Math.min(p1.x, p2.x);
                const endX = Math.max(p1.x, p2.x);
                for (let x = startX + 1; x < endX; x++) {
                    if (board[p1.y][x]) pieces.push(board[p1.y][x]);
                }
            }
            return pieces;
        }
        
        function findKing(color, board) {
            const kingName = color === 'red' ? '帥' : '將';
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    if (board[y][x] && board[y][x].name === kingName) {
                        return board[y][x];
                    }
                }
            }
            return null;
        }

        function isKingInCheck(kingColor, board) {
            const king = findKing(kingColor, board);
            if (!king) return true; // If king is not found, it's considered checkmate (or game over)
            const opponentColor = kingColor === 'red' ? 'black' : 'red';
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    const piece = board[y][x];
                    if (piece && piece.color === opponentColor) {
                        // Create a temporary piece object for isValidMove to use,
                        // ensuring its x and y properties reflect its current position on the board.
                        const tempPieceForValidation = {
                            name: piece.name,
                            color: piece.color,
                            x: x, // Use the current iteration's x
                            y: y  // Use the current iteration's y
                        };
                        if (isValidMove(tempPieceForValidation, king.x, king.y, board)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function isLosingMove(piece, toX, toY) {
            // Use the simulateMove helper to get the board state *after* the proposed move
            const tempBoardAfterMove = simulateMove(boardState, piece, toX, toY);
            
            // Check if the player's king is in check on this simulated board
            const isCheck = isKingInCheck(playerColor, tempBoardAfterMove);
            return isCheck;
        }

        function checkEndGame() {
            if (gameOver) return true;
            if (!findKing('red', boardState)) {
                endGame('黑方');
                return true;
            }
            if (!findKing('black', boardState)) {
                endGame('紅方');
                return true;
            }
            const moves = getAllLegalMoves(currentPlayer, boardState);
            if (moves.length === 0) {
                if (isKingInCheck(currentPlayer, boardState)) {
                    endGame(currentPlayer === 'red' ? '黑方' : '紅方');
                } else {
                    endGame(null, true); // Stalemate
                }
                return true;
            }
            return false;
        }
        
        async function endGame(winner, isDraw = false) {
            gameOver = true;
            if (aiThinkingInterval) clearInterval(aiThinkingInterval);
            aiThinkingInterval = null;
            updateUndoButton();
            
            let result;
            if (isDraw) {
                statusEl.textContent = '和局！';
                result = 'draw';
            } else {
                statusEl.textContent = `遊戲結束！${winner}獲勝！`;
                const winnerColor = winner === '紅方' ? 'red' : 'black';
                if (winnerColor === playerColor) {
                    showVictoryModal();
                    result = 'win';
                } else {
                    showDefeatModal();
                    result = 'loss';
                }
            }
            
            // 儲存遊戲結果到 Supabase
            await saveGameResult(result);
        }

        // --- 新增：Supabase 相關函式 ---
        async function saveGameResult(result) {
            if (!supabase) {
                console.log('Supabase 未初始化，無法儲存遊戲紀錄。');
                return;
            }
            try {
                const { error } = await supabase
                    .from('game_history_chess') // 您的資料表名稱
                    .insert([
                        { 
                            user_id: userId, 
                            result: result, // 'win', 'loss', or 'draw'
                            difficulty: aiDifficulty, // 'intermediate', 'expert', or 'grandmaster'
                            played_at: new Date().toISOString()
                        }
                    ]);
                if (error) throw error;
                console.log('遊戲紀錄已儲存:', { result, difficulty: aiDifficulty });
            } catch (error) {
                console.error('儲存遊戲紀錄失敗:', error.message);
            }
        }

        async function showHistoryModal() {
            if (!supabase) {
                historyErrorEl.textContent = '資料庫連線失敗，無法讀取紀錄。';
                historyErrorEl.classList.remove('hidden');
                historyModal.classList.add('show');
                return;
            }

            historyErrorEl.classList.add('hidden');
            historyTableBodyEl.innerHTML = '<tr><td colspan="3">讀取中...</td></tr>';
            historyStatsEl.innerHTML = '';
            historyModal.classList.add('show');

            try {
                const { data, error } = await supabase
                    .from('game_history_chess')
                    .select('result, difficulty, played_at')
                    .eq('user_id', userId)
                    .order('played_at', { ascending: false });

                if (error) throw error;

                populateHistoryModal(data);

            } catch (error) {
                console.error('讀取遊戲紀錄失敗:', error.message);
                historyTableBodyEl.innerHTML = '';
                historyErrorEl.textContent = `讀取紀錄失敗: ${error.message}`;
                historyErrorEl.classList.remove('hidden');
            }
        }

        function populateHistoryModal(records) {
            // 計算統計數據
            const totalGames = records.length;
            const wins = records.filter(r => r.result === 'win').length;
            const losses = records.filter(r => r.result === 'loss').length;
            const draws = records.filter(r => r.result === 'draw').length;
            
            historyStatsEl.innerHTML = `
                <div>
                    <div class="stat-value">${totalGames}</div>
                    <div class="stat-label">總場次</div>
                </div>
                <div>
                    <div class="stat-value">${wins}</div>
                    <div class="stat-label">勝利</div>
                </div>
                <div>
                    <div class="stat-value">${losses}</div>
                    <div class="stat-label">失敗</div>
                </div>
                <div>
                    <div class="stat-value">${draws}</div>
                    <div class="stat-label">和局</div>
                </div>
            `;

            // 填充表格
            if (records.length === 0) {
                historyTableBodyEl.innerHTML = '<tr><td colspan="3">尚無遊戲紀錄</td></tr>';
                return;
            }

            historyTableBodyEl.innerHTML = records.map(record => {
                const date = new Date(record.played_at).toLocaleString('zh-TW', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
                let difficultyText;
                switch (record.difficulty) {
                    case 'intermediate': difficultyText = '中手'; break;
                    case 'expert': difficultyText = '高手'; break;
                    case 'grandmaster': difficultyText = '宗師'; break;
                    default: difficultyText = '未知';
                }
                let resultText, resultClass;
                switch (record.result) {
                    case 'win':
                        resultText = '勝利';
                        resultClass = 'result-win';
                        break;
                    case 'loss':
                        resultText = '失敗';
                        resultClass = 'result-loss';
                        break;
                    default:
                        resultText = '和局';
                        resultClass = 'result-draw';
                        break;
                }
                return `
                    <tr>
                        <td>${date}</td>
                        <td>${difficultyText}</td>
                        <td class="${resultClass}">${resultText}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // --- Modal 動畫效果 ---
        function showVictoryModal() {
            const victoryBox = victoryModal.querySelector('.modal-box');
            victoryBox.innerHTML = '<h2>大獲全勝！</h2><p>您已成功擊敗對手！</p>';
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.animationDelay = Math.random() * 5 + 's';
                confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                confetti.style.transform = `scale(${Math.random() * 0.5 + 0.5})`;
                victoryBox.appendChild(confetti);
            }
            victoryModal.classList.add('show');
        }

        function showDefeatModal() {
            const defeatBox = defeatModal.querySelector('.modal-box');
            defeatBox.innerHTML = '<h2>再接再厲！</h2><p>失敗乃成功之母，整理旗鼓，再挑戰一局！</p>';
            for (let i = 0; i < 15; i++) {
                const leaf = document.createElement('div');
                leaf.classList.add('leaf');
                leaf.style.left = (Math.random() * 120 - 20) + '%';
                leaf.style.animationDelay = (Math.random() * 4) + 's';
                leaf.style.animationDuration = (Math.random() * 2 + 3) + 's';
                defeatBox.appendChild(leaf);
            }
            defeatModal.classList.add('show');
        }

        function triggerAIMove() {
            isPlayerTurn = false;
            updateUndoButton();
            statusEl.textContent = `輪到 AI (黑方) 思考中...`;

            searchStartTime = performance.now(); // 記錄AI思考開始時間

            // Use setTimeout to allow UI to update before AI starts heavy computation
            setTimeout(() => {
                if (gameOver) return;
                
                let thinkTime = 0;
                // Clear any existing interval to prevent multiple running
                if (aiThinkingInterval) clearInterval(aiThinkingInterval);
                aiThinkingInterval = setInterval(() => {
                    thinkTime++;
                    statusEl.textContent = `輪到 AI (黑方) 思考中 (${thinkTime})...`;
                }, 1000);

                const bestMove = findBestMove();
                
                if(aiThinkingInterval) clearInterval(aiThinkingInterval); // Clear interval once move is found
                aiThinkingInterval = null;

                if (bestMove) {
                    // Find the actual piece object on the current boardState
                    const pieceToMove = boardState[bestMove.piece.y][bestMove.piece.x];
                    aiLastMove = { x: bestMove.toX, y: bestMove.toY };
                    performMove(pieceToMove, bestMove.toX, bestMove.toY, boardState, false);
                    renderBoard();
                    if (checkEndGame()) return;
                    switchPlayer();
                } else {
                    // If AI cannot find a move, it's a stalemate or checkmate
                    endGame(playerColor === 'red' ? '紅方' : '黑方');
                }
            }, 50); // Small delay to allow UI to update
        }

        function findBestMove() {
            let bestScore = -Infinity;
            let bestMove = null;
            let currentBestMove = null; // To store the best move found so far if time runs out
            
            const moves = getAllLegalMoves(aiColor, boardState);
            
            // Sort moves to prioritize captures and checks for better alpha-beta pruning
            moves.sort((a, b) => {
                const aTargetValue = a.target ? pieceValues[a.target.name] : 0;
                const bTargetValue = b.target ? pieceValues[b.target.name] : 0;
                
                // Prioritize captures
                if (aTargetValue !== bTargetValue) return bTargetValue - aTargetValue;

                // Further prioritize moves that check the opponent
                const aChecks = isKingInCheck(playerColor, simulateMove(boardState, a.piece, a.toX, a.toY));
                const bChecks = isKingInCheck(playerColor, simulateMove(boardState, b.piece, b.toX, b.toY));

                if (aChecks && !bChecks) return -1;
                if (!aChecks && bChecks) return 1;

                return 0; // Keep original order if no clear priority
            });

            if (moves.length === 0) return null;

            for (const move of moves) {
                // Check time limit for Grandmaster difficulty
                if (aiDifficulty === 'grandmaster' && (performance.now() - searchStartTime) > AI_TIME_LIMIT_MS) {
                    console.log("AI Time limit reached, returning current best move.");
                    return currentBestMove || moves[0]; // Return the best found so far, or the first move
                }

                const boardCopy = simulateMove(boardState, move.piece, move.toX, move.toY); // Use simulateMove helper
                
                // The AI is the maximizing player, so it's looking for the highest score
                const score = minimax(boardCopy, AI_CURRENT_SEARCH_DEPTH - 1, false, -Infinity, Infinity);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                    currentBestMove = move; // Update current best move
                }
            }
            return bestMove;
        }

        function minimax(board, depth, isMaximizing, alpha, beta) {
            // Time limit check at the beginning of each minimax call
            if (aiDifficulty === 'grandmaster' && (performance.now() - searchStartTime) > AI_TIME_LIMIT_MS) {
                return evaluateBoard(board); // Return current evaluation if time is up
            }

            if (depth === 0) return quiescenceSearch(board, alpha, beta, isMaximizing, 2); // Quiescence search for captures
            
            const currentTurnColor = isMaximizing ? aiColor : playerColor;
            const moves = getAllLegalMoves(currentTurnColor, board);

            if (moves.length === 0) {
                // Check for checkmate or stalemate
                if (isKingInCheck(currentTurnColor, board)) {
                    return isMaximizing ? -100000 : 100000; // Checkmate: very high/low score
                }
                return 0; // Stalemate: draw
            }

            // Sort moves for better alpha-beta pruning
            moves.sort((a, b) => {
                const aTargetValue = a.target ? pieceValues[a.target.name] : 0;
                const bTargetValue = b.target ? pieceValues[b.target.name] : 0;
                
                // Prioritize captures
                if (aTargetValue !== bTargetValue) return bTargetValue - aTargetValue;

                // Further prioritize moves that check the opponent
                const aChecks = isKingInCheck(isMaximizing ? playerColor : aiColor, simulateMove(board, a.piece, a.toX, a.toY));
                const bChecks = isKingInCheck(isMaximizing ? playerColor : aiColor, simulateMove(board, b.piece, b.toX, b.toY));

                if (aChecks && !bChecks) return -1;
                if (!aChecks && bChecks) return 1;

                return 0;
            });

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const boardCopy = simulateMove(board, move.piece, move.toX, move.toY); // Use simulateMove helper
                    const evaluation = minimax(boardCopy, depth - 1, false, alpha, beta);
                    maxEval = Math.max(maxEval, evaluation);
                    alpha = Math.max(alpha, evaluation);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const boardCopy = simulateMove(board, move.piece, move.toX, move.toY); // Use simulateMove helper
                    const evaluation = minimax(boardCopy, depth - 1, true, alpha, beta);
                    minEval = Math.min(minEval, evaluation);
                    beta = Math.min(beta, evaluation);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }
        
        // Helper to simulate a move without modifying the original board
        function simulateMove(board, piece, toX, toY) {
            const tempBoard = JSON.parse(JSON.stringify(board));
            // Find the piece on the tempBoard using its current coordinates from the 'piece' object
            const fromX = piece.x;
            const fromY = piece.y;

            // Retrieve the piece from the tempBoard. This piece object is a *copy*
            // and its x, y properties need to be updated for the simulation.
            // Ensure tempBoard[fromY] exists before accessing tempBoard[fromY][fromX]
            if (!tempBoard[fromY] || !tempBoard[fromY][fromX]) {
                // This scenario indicates an inconsistency, possibly a piece not being where it's expected.
                // For a robust simulation, we should ideally not reach here if the input 'board' is valid.
                // However, as a fallback, we can try to find the piece by its name and color if needed,
                // but for performance and correctness, it's better to ensure 'piece.x' and 'piece.y' are always correct.
                console.warn(`Attempted to simulate move for piece not found at (${fromX}, ${fromY}) on tempBoard. Piece:`, piece);
                // Return original board to prevent further errors in simulation chain
                return board; 
            }
            const pieceToMoveInTempBoard = tempBoard[fromY][fromX];
            
            // Update the coordinates of the piece object *within the tempBoard*
            pieceToMoveInTempBoard.x = toX;
            pieceToMoveInTempBoard.y = toY;
            
            tempBoard[toY][toX] = pieceToMoveInTempBoard;
            tempBoard[fromY][fromX] = null; // Clear the original position
            
            return tempBoard;
        }

        // Quiescence search to evaluate only "noisy" positions (captures)
        function quiescenceSearch(board, alpha, beta, isMaximizing, depth) {
            // Time limit check
            if (aiDifficulty === 'grandmaster' && (performance.now() - searchStartTime) > AI_TIME_LIMIT_MS) {
                return evaluateBoard(board);
            }
            if (depth === 0) return evaluateBoard(board); // Limit quiescence search depth

            const stand_pat = evaluateBoard(board);

            if (isMaximizing) {
                alpha = Math.max(alpha, stand_pat);
            } else {
                beta = Math.min(beta, stand_pat);
            }

            if (alpha >= beta) return isMaximizing ? alpha : beta;

            const currentTurnColor = isMaximizing ? aiColor : playerColor;
            const captureMoves = getAllLegalMoves(currentTurnColor, board)
                .filter(m => m.target !== null); // Only consider capture moves

            // Sort capture moves by value of captured piece
            captureMoves.sort((a, b) => {
                const aTargetValue = a.target ? pieceValues[a.target.name] : 0;
                const bTargetValue = b.target ? pieceValues[b.target.name] : 0;
                return bTargetValue - aTargetValue;
            });

            for (const move of captureMoves) {
                const boardCopy = simulateMove(board, move.piece, move.toX, move.toY); // Use simulateMove helper
                const score = quiescenceSearch(boardCopy, alpha, beta, !isMaximizing, depth - 1);
                if (isMaximizing) {
                    alpha = Math.max(alpha, score);
                } else {
                    beta = Math.min(beta, score);
                }
                if (alpha >= beta) break; // Alpha-beta cut-off
            }
            return isMaximizing ? alpha : beta;
        }

        // Enhanced evaluation function
        function evaluateBoard(board) {
            let score = 0;
            // No need to find AI/player kings here, as they are found within getKingSafetyBonus if needed.

            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    const piece = board[y][x];
                    if (piece) {
                        let value = pieceValues[piece.name];
                        let positionalBonus = getPositionBonus(piece);
                        let mobilityBonus = getMobilityBonus(piece, board);
                        let threatBonus = getThreatBonus(piece, board);
                        let kingSafetyBonus = 0;

                        if (aiDifficulty === 'grandmaster') {
                            // Grandmaster specific evaluation
                            const kingName = piece.color === 'red' ? '帥' : '將';
                            if (piece.name === kingName) { // Check if the piece is a king
                                kingSafetyBonus = getKingSafetyBonus(piece, board, piece.color);
                            }
                            // Central control bonus (example for pawns/soldiers)
                            if ((piece.name === '兵' || piece.name === '卒') && (x >= 3 && x <= 5)) {
                                positionalBonus += 5; // Small bonus for central pawns
                            }
                        }

                        const totalValue = value + positionalBonus + mobilityBonus + threatBonus + kingSafetyBonus;
                        score += (piece.color === aiColor) ? totalValue : -totalValue;
                    }
                }
            }
            return score;
        }
        
        function getPositionBonus(piece) {
            const { name, color, x, y } = piece;
            let pst;
            if (aiDifficulty === 'intermediate') {
                // Keep the simple pawn bonus for intermediate
                let bonus = 0;
                if (piece.name === '兵' && piece.y < 5) {
                    bonus += (4 - piece.y) * 20;
                } else if (piece.name === '卒' && piece.y > 4) {
                    bonus += (piece.y - 5) * 20;
                }
                return bonus;
            } else { // For expert and grandmaster, use PSTs
                if (color === 'red') {
                    switch (name) {
                        case '帥': pst = PST_GENERAL_RED; break;
                        case '仕': pst = PST_ADVISOR_RED; break;
                        case '相': pst = PST_ELEPHANT_RED; break;
                        case '俥': pst = PST_ROOK_RED; break;
                        case '傌': pst = PST_HORSE_RED; break;
                        case '砲': pst = PST_CANNON_RED; break;
                        case '兵': pst = PST_PAWN_RED; break;
                        default: return 0;
                    }
                    return pst[y]?.[x] || 0;
                } else { // black
                    switch (name) {
                        case '將': pst = PST_GENERAL_BLACK; break;
                        case '士': pst = PST_ADVISOR_BLACK; break;
                        case '象': pst = PST_ELEPHANT_BLACK; break;
                        case '車': pst = PST_ROOK_BLACK; break;
                        case '馬': pst = PST_HORSE_BLACK; break;
                        case '炮': pst = PST_CANNON_BLACK; break;
                        case '卒': pst = PST_PAWN_BLACK; break;
                        default: return 0;
                    }
                    return pst[y]?.[x] || 0;
                }
            }
        }

        function getMobilityBonus(piece, board) {
            if (aiDifficulty !== 'grandmaster') return 0; // Only for Grandmaster
            const moves = getLegalMoves(piece, board);
            return moves.length * 2; // Each legal move adds 2 points
        }

        function getThreatBonus(piece, board) {
            if (aiDifficulty !== 'grandmaster') return 0; // Only for Grandmaster
            let bonus = 0;
            const opponentColor = piece.color === 'red' ? 'black' : 'red';

            // Check if this piece is attacking an opponent's piece
            const moves = getLegalMoves(piece, board);
            for (const move of moves) {
                const target = board[move.toY][move.toX];
                if (target && target.color === opponentColor) {
                    bonus += pieceValues[target.name] * 0.1; // Small bonus for attacking
                    // Check if the attacked piece is undefended
                    const tempBoard = simulateMove(board, piece, move.toX, move.toY);
                    const isDefended = isPieceDefended(target, tempBoard, opponentColor);
                    if (!isDefended) {
                        bonus += pieceValues[target.name] * 0.2; // Larger bonus if undefended
                    }
                }
            }

            // Check if this piece is attacked by opponent and undefended
            const myColor = piece.color;
            const attackingOpponentMoves = getAllLegalMoves(opponentColor, board);
            for (const oppMove of attackingOpponentMoves) {
                if (oppMove.toX === piece.x && oppMove.toY === piece.y) {
                    // This piece is attacked
                    const isDefended = isPieceDefended(piece, board, myColor);
                    if (!isDefended) {
                        bonus -= pieceValues[piece.name] * 0.5; // Significant penalty if undefended and attacked
                    }
                }
            }
            return bonus;
        }

        function isPieceDefended(piece, board, defenderColor) {
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    const defender = board[y][x];
                    if (defender && defender.color === defenderColor && defender !== piece) {
                        // Create a temporary defender piece for isValidMove to use
                        const tempDefenderForValidation = {
                            name: defender.name,
                            color: defender.color,
                            x: x,
                            y: y
                        };
                        if (isValidMove(tempDefenderForValidation, piece.x, piece.y, board)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function getKingSafetyBonus(king, board, kingColor) {
            let safety = 0;
            const opponentColor = kingColor === 'red' ? 'black' : 'red';

            // Check for immediate threats
            if (isKingInCheck(kingColor, board)) {
                safety -= 100; // Major penalty for being in check
            }

            // Check for advisors/elephants protection
            const palaceMinX = 3, palaceMaxX = 5;
            const palaceMinY = kingColor === 'red' ? 7 : 0;
            const palaceMaxY = kingColor === 'red' ? 9 : 2;

            let advisorsCount = 0;
            let elephantsCount = 0;

            for (let y = palaceMinY; y <= palaceMaxY; y++) {
                for (let x = palaceMinX; x <= palaceMaxX; x++) {
                    const piece = board[y][x];
                    if (piece && piece.color === kingColor) {
                        if (piece.name === (kingColor === 'red' ? '仕' : '士')) advisorsCount++;
                        if (piece.name === (kingColor === 'red' ? '相' : '象')) elephantsCount++;
                    }
                }
            }

            if (advisorsCount === 2) safety += 30; // Both advisors present
            if (elephantsCount === 2) safety += 30; // Both elephants present
            if (advisorsCount === 1) safety += 10;
            if (elephantsCount === 1) safety += 10;

            // Proximity of opponent pieces to the palace
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    const piece = board[y][x];
                    if (piece && piece.color === opponentColor) {
                        const dist = Math.abs(x - king.x) + Math.abs(y - king.y);
                        if (dist <= 2) { // Opponent piece very close to king
                            safety -= pieceValues[piece.name] * 0.05;
                        } else if (dist <= 4) { // Opponent piece near palace
                            safety -= pieceValues[piece.name] * 0.02;
                        }
                    }
                }
            }
            return safety;
        }


        function getLegalMoves(piece, board) {
            const moves = [];
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    // Check if the move is physically valid
                    if (isValidMove(piece, x, y, board)) {
                        // Simulate the move to check if the king would be in check
                        const tempBoardAfterMove = simulateMove(board, piece, x, y);
                        
                        // If the king is NOT in check after the move, it's a legal move
                        if (!isKingInCheck(piece.color, tempBoardAfterMove)) {
                            // originalTarget needs to be retrieved before simulating the move
                            const originalTarget = board[y][x]; // Get target from the original board
                            moves.push({ piece, toX: x, toY: y, target: originalTarget });
                        }
                    }
                }
            }
            return moves;
        }
        
        function getPhysicalMoves(piece, board) {
            const moves = [];
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    if (isValidMove(piece, x, y, board)) {
                        moves.push({ toX: x, toY: y });
                    }
                }
            }
            return moves;
        }

        function getAllLegalMoves(color, board) {
            const moves = [];
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    const piece = board[y][x];
                    if (piece && piece.color === color) {
                        const legalPieceMoves = getLegalMoves(piece, board);
                        legalPieceMoves.forEach(move => {
                            moves.push({ piece, toX: move.toX, toY: move.toY, target: board[move.toY][move.toX] });
                        });
                    }
                }
            }
            return moves;
        }
        
        function goToMainMenu() {
            if (aiThinkingInterval) {
                clearInterval(aiThinkingInterval);
                aiThinkingInterval = null;
            }
            gameWrapper.classList.add('hidden');
            mainMenu.classList.remove('hidden');
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('show'));
        }

        // --- 事件監聽 ---
        boardEl.addEventListener('click', handleBoardClick);
        window.addEventListener('resize', renderBoard); 
        
        restartBtn.addEventListener('click', () => restartConfirmModal.classList.add('show'));
        undoBtn.addEventListener('click', handleUndo);
        backToMenuBtn.addEventListener('click', () => backToMenuConfirmModal.classList.add('show'));
        historyBtn.addEventListener('click', showHistoryModal); // 新增

        difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                aiDifficulty = button.dataset.difficulty;
                // Set AI search depth based on difficulty
                if (aiDifficulty === 'intermediate') {
                    AI_CURRENT_SEARCH_DEPTH = 2;
                } else if (aiDifficulty === 'expert') {
                    AI_CURRENT_SEARCH_DEPTH = 3;
                } else if (aiDifficulty === 'grandmaster') {
                    AI_CURRENT_SEARCH_DEPTH = 4; // Deeper search for grandmaster
                }
                
                mainMenu.classList.add('hidden');
                gameWrapper.classList.remove('hidden');
                initGame();
            });
        });

        victoryModal.addEventListener('click', () => victoryModal.classList.remove('show'));
        defeatModal.addEventListener('click', () => {
            defeatModal.classList.remove('show');
            initGame();
        });

        confirmYesBtn.addEventListener('click', () => {
            if (pendingMove) {
                movePiece(pendingMove.piece, pendingMove.toX, pendingMove.toY);
                pendingMove = null;
            }
            confirmModal.classList.remove('show');
        });
        confirmNoBtn.addEventListener('click', () => {
            pendingMove = null;
            selectPiece(selectedPiece);
            confirmModal.classList.remove('show');
        });
        
        undoYesBtn.addEventListener('click', executeUndo);
        undoNoBtn.addEventListener('click', () => undoModal.classList.remove('show'));
        
        restartYesBtn.addEventListener('click', () => {
            restartConfirmModal.classList.remove('show');
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                Tone.start().then(initGame);
            } else {
                initGame();
            }
        });
        restartNoBtn.addEventListener('click', () => restartConfirmModal.classList.remove('show'));
        
        backToMenuYesBtn.addEventListener('click', goToMainMenu);
        backToMenuNoBtn.addEventListener('click', () => backToMenuConfirmModal.classList.remove('show'));
        
        historyCloseBtn.addEventListener('click', () => historyModal.classList.remove('show')); // 新增

        // --- 遊戲啟動 ---
        setupSounds();
    </script>

</body>
</html>
