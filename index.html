<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>藍氏象棋</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --board-bg: #d8c3a5;
            --board-border: #8e795e;
            --piece-bg: #f9f6f2;
            --piece-shadow: rgba(0,0,0,0.3);
            --red-text: #c84b31;
            --black-text: #2d2d2d;
            --selected-glow: #f7b733;
            --hint-color: rgba(10, 132, 38, 0.5);
            --font-family-status: 'Noto Serif TC', serif;
            --font-family-piece: 'Ma Shan Zheng', cursive;
        }

        body {
            font-family: var(--font-family-status);
            background-color: #f0e9dc;
            background-image: url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAH0BDgDASIAAhEBAxEB/8QAHQAAAQQDAQEAAAAAAAAAAAAAAAQFBgcCAwgBCf/EAGEQAAEDAwIDBAUGCQkJCwgDAQECAwQABREGEiExBxNBUWEUIjJxgZEVFiNCUpKhsQkzNDU2NidwdIXJENTY4KiwtFERVWTlKOTo7PC8PE4Vld0g4SVo8MmRmWVwv/EABsBAQEBAQEBAQEAAAAAAAAAAAABAgMEBQYH/8QAPBEAAgECAwQHBgQGAgMBAAAAAAECEQMEEiExBUFRcRNSYZEGFCIygaGxwdHwI0JS4fEzYnLxJIKiFUP/2gAMAwEAAhEDEQA/APKYoooqRhRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQBRRRQ-1EAmFFFFIoUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUUUAUUU-D/9k=');
            background-size: cover;
            background-position: center;
            overflow-y: auto;
        }

        .game-wrapper {
            background-color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            padding: 1rem;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 100vh;
        }

        .game-container {
            width: 100%;
            max-width: 700px;
            margin: 2rem auto; 
            padding: 1.5rem;
            background-color: var(--board-bg);
            background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
            border-radius: 15px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.25), 0 5px 10px rgba(0,0,0,0.15);
            border: 8px solid var(--board-border);
        }
        
        #game-board {
            position: relative;
            background-image: url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' viewBox='0 0 80 90' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cstyle%3E.river-text %7B font-size: 8px; font-family: 'Ma Shan Zheng', cursive; fill: %238e795e; %7D%3C/style%3E%3C/defs%3E%3C!-- Vertical Lines --%3E%3Cpath d='M0 0 V40 M0 50 V90 M10 0 V40 M10 50 V90 M20 0 V40 M20 50 V90 M30 0 V40 M30 50 V90 M40 0 V40 M40 50 V90 M50 0 V40 M50 50 V90 M60 0 V40 M60 50 V90 M70 0 V40 M70 50 V90 M80 0 V40 M80 50 V90' stroke='%238e795e' stroke-width='0.5'/%3E%3C!-- Horizontal Lines --%3E%3Cpath d='M0 0 H80 M0 10 H80 M0 20 H80 M0 30 H80 M0 40 H80 M0 50 H80 M0 60 H80 M0 70 H80 M0 80 H80 M0 90 H80' stroke='%238e795e' stroke-width='0.5'/%3E%3C!-- Palaces --%3E%3Cpath d='M30 0 L50 20 M50 0 L30 20 M30 70 L50 90 M50 70 L30 90' stroke='%238e795e' stroke-width='0.5'/%3E%3C!-- River --%3E%3Ctext x='7' y='48' class='river-text'%3E楚 河%3C/text%3E%3Ctext x='47' y='48' class='river-text'%3E漢 界%3C/text%3E%3C/svg%3E");
            background-size: 100% 100%;
            background-repeat: no-repeat;
            background-position: center;
            aspect-ratio: 9/10;
        }

        .piece {
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1.6rem, 3.5vw, 2.0rem);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            position: absolute;
            background-color: var(--piece-bg);
            box-shadow: inset 0 -3px 5px rgba(0,0,0,0.1), 0 5px 10px var(--piece-shadow);
            border: 3px solid var(--board-border);
            z-index: 10;
            transform: translate(-50%, -50%);
        }
        
        .piece.red-piece {
            color: var(--red-text);
            border: 3px solid var(--red-text);
            text-shadow: 0 0 5px rgba(200, 75, 49, 0.5);
        }

        .piece.black-piece {
            color: var(--black-text);
            border: 3px solid var(--black-text);
            text-shadow: 0 0 5px rgba(45, 45, 45, 0.3);
        }
        
        .piece.selected {
            box-shadow: 0 0 25px 8px var(--selected-glow), inset 0 -3px 5px rgba(0,0,0,0.1);
            z-index: 20;
        }

        .piece.ai-last-move {
            animation: blink-animation 1.5s infinite;
            z-index: 15;
        }

        @keyframes blink-animation {
            0%, 100% { 
                box-shadow: 0 0 25px 8px var(--selected-glow), inset 0 -3px 5px rgba(0,0,0,0.1); 
                opacity: 1;
            }
            50% { 
                box-shadow: inset 0 -3px 5px rgba(0,0,0,0.1), 0 5px 10px var(--piece-shadow);
                opacity: 0.6;
            }
        }

        .hint {
            position: absolute;
            background-color: var(--hint-color);
            border-radius: 50%;
            z-index: 5;
            animation: pulse 1.5s infinite;
            transform: translate(-50%, -50%);
        }

        @keyframes pulse {
            0% { opacity: 0.7; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0.7; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        #game-status {
            font-family: var(--font-family-status);
            font-size: 1.25rem;
            font-weight: 600;
            text-align: center;
            padding: 1rem;
            min-height: 70px;
            color: var(--black-text);
            background-color: rgba(255,255,255,0.6);
            border-radius: 10px;
            margin-bottom: 1rem;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }
        
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            /* 增加與棋盤的距離 */
            margin-top: 2.5rem; 
        }

        .control-button {
            background-color: var(--board-border);
            color: var(--piece-bg);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            font-size: 1.1rem;
            font-family: var(--font-family-status);
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px var(--piece-shadow);
        }

        .control-button:hover:not(:disabled) {
            background-color: #7a684e;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px var(--piece-shadow);
        }
        
        .control-button:disabled {
            background-color: #b0a390;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Modal Base Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }
        .modal.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-box {
            padding: 2rem 3rem;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transform: scale(0.7);
            transition: transform 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            position: relative;
            overflow: hidden;
            max-width: 90%;
            width: 450px;
        }
        .modal.show .modal-box {
            transform: scale(1);
        }
        .modal-box h2 {
            font-family: var(--font-family-piece);
            font-size: 3.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        .modal-box p {
            font-size: 1.2rem;
            margin-bottom: 1.5rem;
        }
        .modal-box .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        .modal-box button {
            padding: 0.5rem 1.5rem;
            border-radius: 8px;
            border: none;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .modal-box .confirm-yes {
            background-color: var(--red-text);
            color: white;
        }
        .modal-box .confirm-yes:hover {
            background-color: #a53c27;
        }
        .modal-box .confirm-no {
            background-color: #ccc;
            color: #333;
        }
        .modal-box .confirm-no:hover {
            background-color: #bbb;
        }
        
        #victory-modal .modal-box {
             background: linear-gradient(135deg, #fdfcfb, #e2d1c3);
             color: var(--board-border);
        }
        .confetti {
            position: absolute;
            width: 10px;
            height: 20px;
            background-color: #f00;
            top: -50px;
            opacity: 0;
            animation: fall 5s linear infinite;
        }
        @keyframes fall {
            to {
                transform: translateY(120vh) rotate(360deg);
                opacity: 1;
            }
        }
        
        #defeat-modal .modal-box {
            background: linear-gradient(135deg, #6c757d, #495057);
            color: #f8f9fa;
        }
        .leaf {
            position: absolute;
            width: 20px;
            height: 10px;
            background-color: #a0a0a0;
            opacity: 0.5;
            border-radius: 10px 0;
            top: -20px;
            animation: blow-wind 4s linear infinite;
        }
        @keyframes blow-wind {
          0% { transform: translateX(-50px) rotate(0deg); opacity: 0; }
          20% { opacity: 0.7; }
          100% { transform: translateX(300px) translateY(150px) rotate(720deg); opacity: 0; }
        }

        #confirm-modal .modal-box, #undo-modal .modal-box, #restart-confirm-modal .modal-box {
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0);
            color: #333;
        }

    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div class="game-wrapper">
        <div class="game-container">
            <div id="game-status"></div>
            <div id="game-board"></div>
            <div class="game-controls">
                <button id="undo-button" class="control-button"></button>
                <button id="restart-button" class="control-button">重新開始</button>
            </div>
        </div>
    </div>

    <!-- 各式彈出視窗 -->
    <div id="victory-modal" class="modal">
        <div class="modal-box">
            <h2>大獲全勝！</h2>
            <p>您已成功擊敗對手！</p>
        </div>
    </div>

    <div id="defeat-modal" class="modal">
        <div class="modal-box">
            <h2>再接再厲！</h2>
            <p>失敗乃成功之母，整理旗鼓，再挑戰一局！</p>
        </div>
    </div>

    <div id="confirm-modal" class="modal">
        <div class="modal-box">
            <h2>三思而後行</h2>
            <p>此步兇險，將(帥)有被吃之虞，是否確定要走？</p>
            <div class="modal-buttons">
                <button id="confirm-yes-btn" class="confirm-yes">確定</button>
                <button id="confirm-no-btn" class="confirm-no">取消</button>
            </div>
        </div>
    </div>
    
    <div id="undo-modal" class="modal">
        <div class="modal-box">
            <h2>大丈夫，能屈能伸</h2>
            <p id="undo-message">一著不慎，滿盤皆輸。真的要收回這一步嗎？</p>
            <div class="modal-buttons">
                <button id="undo-yes-btn" class="confirm-yes">時光倒流</button>
                <button id="undo-no-btn" class="confirm-no">我再想想</button>
            </div>
        </div>
    </div>

    <div id="restart-confirm-modal" class="modal">
        <div class="modal-box">
            <h2>重新開始？</h2>
            <p>確定要放棄目前的對局，重新開始一盤嗎？</p>
            <div class="modal-buttons">
                <button id="restart-yes-btn" class="confirm-yes">確定</button>
                <button id="restart-no-btn" class="confirm-no">取消</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM 元素 ---
        const boardEl = document.getElementById('game-board');
        const statusEl = document.getElementById('game-status');
        const restartBtn = document.getElementById('restart-button');
        const undoBtn = document.getElementById('undo-button');
        
        // --- 彈出視窗 ---
        const victoryModal = document.getElementById('victory-modal');
        const defeatModal = document.getElementById('defeat-modal');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmYesBtn = document.getElementById('confirm-yes-btn');
        const confirmNoBtn = document.getElementById('confirm-no-btn');
        const undoModal = document.getElementById('undo-modal');
        const undoMessageEl = document.getElementById('undo-message');
        const undoYesBtn = document.getElementById('undo-yes-btn');
        const undoNoBtn = document.getElementById('undo-no-btn');
        const restartConfirmModal = document.getElementById('restart-confirm-modal');
        const restartYesBtn = document.getElementById('restart-yes-btn');
        const restartNoBtn = document.getElementById('restart-no-btn');

        // --- 遊戲常數 ---
        const BOARD_COLS = 9;
        const BOARD_ROWS = 10;
        const AI_SEARCH_DEPTH = 3;
        const MAX_UNDO_COUNT = 3;

        // --- 棋子設定 ---
        const PIECE_CONFIG = {
            'k': { name: '將', color: 'black' }, 'g': { name: '帥', color: 'red' },
            'a': { name: '士', color: 'black' }, 'd': { name: '仕', color: 'red' },
            'e': { name: '象', color: 'black' }, 'h': { name: '相', color: 'red' },
            'r': { name: '車', color: 'black' }, 't': { name: '俥', color: 'red' },
            'n': { name: '馬', color: 'black' }, 'm': { name: '傌', color: 'red' },
            'c': { name: '炮', color: 'black' }, 'x': { name: '砲', color: 'red' },
            'p': { name: '卒', color: 'black' }, 's': { name: '兵', color: 'red' }
        };
        const pieceValues = { '帥': 10000, '將': 10000, '仕': 120, '士': 120, '相': 120, '象': 120, '俥': 500, '車': 500, '傌': 300, '馬': 300, '砲': 320, '炮': 320, '兵': 80, '卒': 80 };

        const initialBoardSetup = [
            "r", "n", "e", "a", "k", "a", "e", "n", "r",
            "",  "",  "",  "",  "",  "",  "",  "",  "",
            "", "c",  "",  "",  "",  "",  "", "c",  "",
            "p", "", "p",  "", "p",  "", "p",  "", "p",
            "",  "",  "",  "",  "",  "",  "",  "",  "",
            "",  "",  "",  "",  "",  "",  "",  "",  "",
            "s", "", "s",  "", "s",  "", "s",  "", "s",
            "", "x",  "",  "",  "",  "",  "", "x",  "",
            "",  "",  "",  "",  "",  "",  "",  "",  "",
            "t", "m", "h", "d", "g", "d", "h", "m", "t",
        ];
        
        // --- 遊戲狀態變數 ---
        let boardState = [];
        let playerColor = 'red';
        let aiColor = 'black';
        let currentPlayer = 'red';
        let selectedPiece = null;
        let gameOver = false;
        let isPlayerTurn = true;
        let pendingMove = null;
        let moveHistory = [];
        let undoCount = MAX_UNDO_COUNT;
        let aiLastMove = null;
        let aiThinkingInterval = null;

        // --- 音效 ---
        let moveSound, captureSound;
        
        function setupSounds() {
            if (typeof Tone === 'undefined') return;
            moveSound = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).toDestination();
            captureSound = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' } }).toDestination();
        }

        function playSound(type) {
             if (typeof Tone === 'undefined' || Tone.context.state !== 'running') return;
            try {
                if (type === 'move') moveSound.triggerAttackRelease('0.1');
                if (type === 'capture') captureSound.triggerAttackRelease('C3', '8n');
            } catch (e) { console.error("音效播放失敗:", e); }
        }

        function initGame() {
            if (aiThinkingInterval) clearInterval(aiThinkingInterval);
            aiThinkingInterval = null;
            gameOver = false;
            currentPlayer = 'red';
            selectedPiece = null;
            isPlayerTurn = true;
            pendingMove = null;
            moveHistory = [];
            undoCount = MAX_UNDO_COUNT;
            aiLastMove = null;
            
            statusEl.textContent = '歡迎來到藍氏象棋！紅方先行。';
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('show'));
            
            boardState = Array(BOARD_ROWS).fill(null).map(() => Array(BOARD_COLS).fill(null));
            initialBoardSetup.forEach((key, index) => {
                if (key) {
                    const row = Math.floor(index / BOARD_COLS);
                    const col = index % BOARD_COLS;
                    boardState[row][col] = { ...PIECE_CONFIG[key], x: col, y: row };
                }
            });
            updateUndoButton();
            renderBoard();
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            const rect = boardEl.getBoundingClientRect();
            const cellWidth = rect.width / (BOARD_COLS - 1);
            const cellHeight = rect.height / (BOARD_ROWS - 1);
            const pieceSize = Math.min(cellWidth, cellHeight) * 0.95;

            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    const pieceData = boardState[y][x];
                    if (pieceData) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = `piece ${pieceData.color}-piece`;
                        pieceEl.textContent = pieceData.name;
                        
                        pieceEl.style.width = `${pieceSize}px`;
                        pieceEl.style.height = `${pieceSize}px`;
                        
                        const left = x * cellWidth;
                        const top = y * cellHeight;
                        
                        pieceEl.style.left = `${left}px`;
                        pieceEl.style.top = `${top}px`;
                        
                        pieceEl.dataset.x = x;
                        pieceEl.dataset.y = y;

                        // 分開處理玩家選中和AI落子的高亮
                        if (selectedPiece && selectedPiece.x === x && selectedPiece.y === y) {
                            pieceEl.classList.add('selected'); // 玩家選中：持續發光
                            pieceEl.style.transform = 'translate(-50%, -50%) scale(1.08)';
                        } else if (aiLastMove && aiLastMove.x === x && aiLastMove.y === y) {
                            pieceEl.classList.add('ai-last-move'); // AI落子：閃爍
                        }
                        boardEl.appendChild(pieceEl);
                    }
                }
            }
        }
        
        function clearHighlights() {
            document.querySelectorAll('.hint').forEach(el => el.remove());
        }

        function highlightMoves(moves) {
            clearHighlights();
            const rect = boardEl.getBoundingClientRect();
            const cellWidth = rect.width / (BOARD_COLS - 1);
            const cellHeight = rect.height / (BOARD_ROWS - 1);
            const pieceSize = Math.min(cellWidth, cellHeight) * 0.95;
            const hintSize = pieceSize * 0.4;

            moves.forEach(move => {
                const hintEl = document.createElement('div');
                hintEl.className = 'hint';
                hintEl.style.width = `${hintSize}px`;
                hintEl.style.height = `${hintSize}px`;

                const left = move.toX * cellWidth;
                const top = move.toY * cellHeight;
                hintEl.style.left = `${left}px`;
                hintEl.style.top = `${top}px`;

                hintEl.dataset.x = move.toX;
                hintEl.dataset.y = move.toY;
                boardEl.appendChild(hintEl);
            });
        }

        function handleBoardClick(e) {
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                Tone.start();
            }
            if (gameOver || !isPlayerTurn) return;
            
            const rect = boardEl.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const x = Math.round(clickX / (rect.width / (BOARD_COLS - 1)));
            const y = Math.round(clickY / (rect.height / (BOARD_ROWS - 1)));

            if (x < 0 || x >= BOARD_COLS || y < 0 || y >= BOARD_ROWS) return;

            if (selectedPiece) {
                const isPhysicalMove = getPhysicalMoves(selectedPiece, boardState).some(m => m.toX === x && m.toY === y);
                if (isPhysicalMove) {
                    if (isLosingMove(selectedPiece, x, y)) {
                        pendingMove = { piece: selectedPiece, toX: x, toY: y };
                        confirmModal.classList.add('show');
                    } else {
                        movePiece(selectedPiece, x, y);
                    }
                } else {
                    selectedPiece = null;
                    const newClickedPiece = boardState[y]?.[x];
                    if (newClickedPiece && newClickedPiece.color === currentPlayer) {
                        selectPiece(newClickedPiece);
                    } else {
                        aiLastMove = null;
                        renderBoard();
                        clearHighlights();
                    }
                }
            } else {
                const clickedPiece = boardState[y]?.[x];
                if (clickedPiece && clickedPiece.color === currentPlayer) {
                    selectPiece(clickedPiece);
                }
            }
        }
        
        function selectPiece(piece) {
            aiLastMove = null;
            selectedPiece = piece;
            renderBoard();
            const moves = getPhysicalMoves(selectedPiece, boardState);
            highlightMoves(moves);
        }
        
        function movePiece(piece, toX, toY) {
            if (isPlayerTurn) {
                moveHistory.push(JSON.parse(JSON.stringify(boardState)));
            }
            performMove(piece, toX, toY, boardState, false);
            selectedPiece = null;
            clearHighlights();
            renderBoard();
            if (checkEndGame()) return;
            switchPlayer();
            if(!gameOver && currentPlayer === aiColor) triggerAIMove();
        }

        function performMove(piece, toX, toY, currentBoard, isSimulation = false) {
            const fromX = piece.x;
            const fromY = piece.y;
            const targetPiece = currentBoard[toY][toX];
            if (!isSimulation) {
                if (targetPiece) { playSound('capture'); } 
                else { playSound('move'); }
            }
            currentBoard[toY][toX] = { ...piece, x: toX, y: toY };
            currentBoard[fromY][fromX] = null;
        }
        
        function switchPlayer() {
            currentPlayer = (currentPlayer === 'red') ? 'black' : 'red';
            isPlayerTurn = (currentPlayer === playerColor);
            updateStatus();
            updateUndoButton();
        }
        
        function updateStatus() {
            if (gameOver) return;
            if (isPlayerTurn) {
                statusEl.textContent = `輪到您 (紅方) 行動`;
                if (isKingInCheck(playerColor, boardState)) {
                    statusEl.textContent += " (將軍！)";
                }
            } else {
                statusEl.textContent = `輪到 AI (黑方) 思考中...`;
            }
        }
        
        function updateUndoButton() {
            undoBtn.textContent = `悔棋 (${undoCount})`;
            undoBtn.disabled = !(isPlayerTurn && undoCount > 0 && moveHistory.length > 0);
        }

        function handleUndo() {
            const taunts = [
                "大丈夫，能屈能伸。真的要收回這一步嗎？",
                "棋，是這麼下的嗎？確定要悔棋？",
                "哎呀，是不是手滑了？給你個機會反悔。",
                "觀棋不語真君子，落子無悔大丈夫。你確定？",
                "嗯？想耍賴？好吧，就這一次喔！"
            ];
            undoMessageEl.textContent = taunts[Math.floor(Math.random() * taunts.length)];
            undoModal.classList.add('show');
        }

        function executeUndo() {
            if (undoCount <= 0 || moveHistory.length === 0) return;
            undoCount--;
            boardState = moveHistory.pop();
            gameOver = false;
            currentPlayer = playerColor;
            isPlayerTurn = true;
            selectedPiece = null;
            pendingMove = null;
            aiLastMove = null;
            clearHighlights();
            renderBoard();
            updateStatus();
            updateUndoButton();
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('show'));
        }

        // --- 象棋規則 (此區塊未變動) ---
        function isValidMove(piece, toX, toY, board) {
            const target = board[toY][toX];
            if (target && target.color === piece.color) return false;
            const { name, x: fromX, y: fromY } = piece;
            const dx = toX - fromX;
            const dy = toY - fromY;
            switch (name) {
                case '帥': case '將':
                    if (target && (target.name === '將' || target.name === '帥')) {
                        if (dx === 0 && getPiecesBetween(piece, target, board).length === 0) return true;
                    }
                    if (Math.abs(dx) + Math.abs(dy) !== 1) return false;
                    if (toX < 3 || toX > 5) return false;
                    if (piece.color === 'red' && toY < 7) return false;
                    if (piece.color === 'black' && toY > 2) return false;
                    return true;
                case '仕': case '士':
                    if (Math.abs(dx) !== 1 || Math.abs(dy) !== 1) return false;
                    if (toX < 3 || toX > 5) return false;
                    if (piece.color === 'red' && toY < 7) return false;
                    if (piece.color === 'black' && toY > 2) return false;
                    return true;
                case '相': case '象':
                    if (Math.abs(dx) !== 2 || Math.abs(dy) !== 2) return false;
                    if (piece.color === 'red' && toY < 5) return false;
                    if (piece.color === 'black' && toY > 4) return false;
                    if (board[fromY + dy / 2][fromX + dx / 2]) return false;
                    return true;
                case '俥': case '車':
                    if (dx !== 0 && dy !== 0) return false;
                    return getPiecesBetween(piece, {x: toX, y: toY}, board).length === 0;
                case '傌': case '馬':
                    if (!((Math.abs(dx) === 1 && Math.abs(dy) === 2) || (Math.abs(dx) === 2 && Math.abs(dy) === 1))) return false;
                    if (Math.abs(dx) === 2 && board[fromY][fromX + dx / 2]) return false;
                    if (Math.abs(dy) === 2 && board[fromY + dy / 2][fromX]) return false;
                    return true;
                case '砲': case '炮':
                    if (dx !== 0 && dy !== 0) return false;
                    const piecesBetween = getPiecesBetween(piece, {x: toX, y: toY}, board);
                    return target ? piecesBetween.length === 1 : piecesBetween.length === 0;
                case '兵':
                    return (fromY > 4 && dx === 0 && dy === -1) || (fromY <= 4 && ( (dx === 0 && dy === -1) || (Math.abs(dx) === 1 && dy === 0) ));
                case '卒':
                     return (fromY < 5 && dx === 0 && dy === 1) || (fromY >= 5 && ( (dx === 0 && dy === 1) || (Math.abs(dx) === 1 && dy === 0) ));
            }
            return false;
        }
        
        function getPiecesBetween(p1, p2, board) {
            const pieces = [];
            if (p1.x === p2.x) {
                const startY = Math.min(p1.y, p2.y);
                const endY = Math.max(p1.y, p2.y);
                for (let y = startY + 1; y < endY; y++) {
                    if (board[y][p1.x]) pieces.push(board[y][p1.x]);
                }
            } else if (p1.y === p2.y) {
                const startX = Math.min(p1.x, p2.x);
                const endX = Math.max(p1.x, p2.x);
                for (let x = startX + 1; x < endX; x++) {
                    if (board[p1.y][x]) pieces.push(board[p1.y][x]);
                }
            }
            return pieces;
        }
        
        function findKing(color, board) {
            const kingName = color === 'red' ? '帥' : '將';
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    if (board[y][x] && board[y][x].name === kingName) {
                        return board[y][x];
                    }
                }
            }
            return null;
        }

        function isKingInCheck(kingColor, board) {
            const king = findKing(kingColor, board);
            if (!king) return true;
            const opponentColor = kingColor === 'red' ? 'black' : 'red';
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    const piece = board[y][x];
                    if (piece && piece.color === opponentColor) {
                        if (isValidMove(piece, king.x, king.y, board)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function isLosingMove(piece, toX, toY) {
            const tempBoard = JSON.parse(JSON.stringify(boardState));
            const pieceToMove = tempBoard[piece.y][piece.x];
            performMove(pieceToMove, toX, toY, tempBoard, true);
            const opponentMoves = getAllLegalMoves(aiColor, tempBoard);
            for (const move of opponentMoves) {
                if (move.target && (move.target.name === '帥' || move.target.name === '將')) {
                    return true;
                }
            }
            return false;
        }

        function checkEndGame() {
            if (gameOver) return true;
            if (!findKing('red', boardState)) {
                endGame('黑方');
                return true;
            }
            if (!findKing('black', boardState)) {
                endGame('紅方');
                return true;
            }
            const moves = getAllLegalMoves(currentPlayer, boardState);
            if (moves.length === 0) {
                if (isKingInCheck(currentPlayer, boardState)) {
                    endGame(currentPlayer === 'red' ? '黑方' : '紅方');
                } else {
                    endGame(null, true);
                }
                return true;
            }
            return false;
        }
        
        function endGame(winner, isDraw = false) {
            gameOver = true;
            if (aiThinkingInterval) clearInterval(aiThinkingInterval);
            aiThinkingInterval = null;
            updateUndoButton();
            if (isDraw) {
                statusEl.textContent = '和局！';
            } else {
                statusEl.textContent = `遊戲結束！${winner}獲勝！`;
                const winnerColor = winner === '紅方' ? 'red' : 'black';
                if (winnerColor === playerColor) {
                    showVictoryModal();
                } else {
                    showDefeatModal();
                }
            }
        }

        function showVictoryModal() {
            const victoryBox = victoryModal.querySelector('.modal-box');
            victoryBox.innerHTML = '<h2>大獲全勝！</h2><p>您已成功擊敗對手！</p>';
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.animationDelay = Math.random() * 5 + 's';
                confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                confetti.style.transform = `scale(${Math.random() * 0.5 + 0.5})`;
                victoryBox.appendChild(confetti);
            }
            victoryModal.classList.add('show');
        }

        function showDefeatModal() {
            const defeatBox = defeatModal.querySelector('.modal-box');
            defeatBox.innerHTML = '<h2>再接再厲！</h2><p>失敗乃成功之母，整理旗鼓，再挑戰一局！</p>';
            for (let i = 0; i < 15; i++) {
                const leaf = document.createElement('div');
                leaf.classList.add('leaf');
                leaf.style.left = (Math.random() * 120 - 20) + '%';
                leaf.style.animationDelay = (Math.random() * 4) + 's';
                leaf.style.animationDuration = (Math.random() * 2 + 3) + 's';
                defeatBox.appendChild(leaf);
            }
            defeatModal.classList.add('show');
        }

        function triggerAIMove() {
            isPlayerTurn = false;
            updateUndoButton();
            statusEl.textContent = `輪到 AI (黑方) 思考中...`;

            // 使用 setTimeout 確保初始狀態能被渲染
            setTimeout(() => {
                if (gameOver) return;
                
                let thinkTime = 0;
                aiThinkingInterval = setInterval(() => {
                    thinkTime++;
                    statusEl.textContent = `輪到 AI (黑方) 思考中 (${thinkTime})...`;
                }, 1000);

                // 再次使用 setTimeout 將耗時的計算推遲，讓計時器有機會更新
                setTimeout(() => {
                    if (gameOver || checkEndGame()) {
                        if(aiThinkingInterval) clearInterval(aiThinkingInterval);
                        aiThinkingInterval = null;
                        return;
                    }
                    const bestMove = findBestMove();
                    
                    if(aiThinkingInterval) clearInterval(aiThinkingInterval);
                    aiThinkingInterval = null;

                    if (bestMove) {
                        const pieceToMove = boardState[bestMove.piece.y][bestMove.piece.x];
                        aiLastMove = { x: bestMove.toX, y: bestMove.toY };
                        performMove(pieceToMove, bestMove.toX, bestMove.toY, boardState, false);
                        renderBoard();
                        if (checkEndGame()) return;
                        switchPlayer();
                    } else {
                        endGame(playerColor === 'red' ? '紅方' : '黑方');
                    }
                }, 50); // 一個極短的延遲即可
            }, 50);
        }

        function findBestMove() {
            let bestScore = -Infinity;
            let bestMove = null;
            const moves = getAllLegalMoves(aiColor, boardState);
            if (moves.length === 0) return null;
            for (const move of moves) {
                const boardCopy = JSON.parse(JSON.stringify(boardState));
                const pieceCopy = boardCopy[move.piece.y][move.piece.x];
                performMove(pieceCopy, move.toX, move.toY, boardCopy, true);
                const score = minimax(boardCopy, AI_SEARCH_DEPTH - 1, false, -Infinity, Infinity);
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        function minimax(board, depth, isMaximizing, alpha, beta) {
            if (depth === 0) return quiescenceSearch(board, alpha, beta, isMaximizing, 2);
            const moves = getAllLegalMoves(isMaximizing ? aiColor : playerColor, board);
            if (moves.length === 0) return evaluateBoard(board);
            moves.sort((a, b) => {
                const aVal = a.target ? pieceValues[a.target.name] : 0;
                const bVal = b.target ? pieceValues[b.target.name] : 0;
                return bVal - aVal;
            });
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const boardCopy = JSON.parse(JSON.stringify(board));
                    const pieceCopy = boardCopy[move.piece.y][move.piece.x];
                    performMove(pieceCopy, move.toX, move.toY, boardCopy, true);
                    const evaluation = minimax(boardCopy, depth - 1, false, alpha, beta);
                    maxEval = Math.max(maxEval, evaluation);
                    alpha = Math.max(alpha, evaluation);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const boardCopy = JSON.parse(JSON.stringify(board));
                    const pieceCopy = boardCopy[move.piece.y][move.piece.x];
                    performMove(pieceCopy, move.toX, move.toY, boardCopy, true);
                    const evaluation = minimax(boardCopy, depth - 1, true, alpha, beta);
                    minEval = Math.min(minEval, evaluation);
                    beta = Math.min(beta, evaluation);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }
        
        function quiescenceSearch(board, alpha, beta, isMaximizing, depth) {
            const stand_pat = evaluateBoard(board);
            if (depth === 0) return stand_pat;
            if (isMaximizing) {
                alpha = Math.max(alpha, stand_pat);
            } else {
                beta = Math.min(beta, stand_pat);
            }
            if (alpha >= beta) return isMaximizing ? alpha : beta;
            const captureMoves = getAllLegalMoves(isMaximizing ? aiColor : playerColor, board)
                .filter(m => m.target !== null);
            for (const move of captureMoves) {
                const boardCopy = JSON.parse(JSON.stringify(board));
                const pieceCopy = boardCopy[move.piece.y][move.piece.x];
                performMove(pieceCopy, move.toX, move.toY, boardCopy, true);
                const score = quiescenceSearch(boardCopy, alpha, beta, !isMaximizing, depth - 1);
                if (isMaximizing) {
                    alpha = Math.max(alpha, score);
                } else {
                    beta = Math.min(beta, score);
                }
                if (alpha >= beta) break;
            }
            return isMaximizing ? alpha : beta;
        }

        function evaluateBoard(board) {
            let score = 0;
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    const piece = board[y][x];
                    if (piece) {
                        const value = pieceValues[piece.name];
                        const positionBonus = getPositionBonus(piece);
                        const totalValue = value + positionBonus;
                        score += (piece.color === aiColor) ? totalValue : -totalValue;
                    }
                }
            }
            return score;
        }
        
        function getPositionBonus(piece) {
            let bonus = 0;
            const { name, y } = piece;
            if (name === '兵' && y < 5) {
                bonus += (4 - y) * 20;
            } else if (name === '卒' && y > 4) {
                bonus += (y - 5) * 20;
            }
            return bonus;
        }

        function getLegalMoves(piece, board) {
            const moves = [];
            const physicalMoves = getPhysicalMoves(piece, board);
            for (const move of physicalMoves) {
                const tempBoard = JSON.parse(JSON.stringify(board));
                const pieceToMove = tempBoard[piece.y][piece.x];
                performMove(pieceToMove, move.toX, move.toY, tempBoard, true);
                if (!isKingInCheck(piece.color, tempBoard)) {
                    moves.push(move);
                }
            }
            return moves;
        }
        
        function getPhysicalMoves(piece, board) {
            const moves = [];
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    if (isValidMove(piece, x, y, board)) {
                        moves.push({ toX: x, toY: y });
                    }
                }
            }
            return moves;
        }

        function getAllLegalMoves(color, board) {
            const moves = [];
            for (let y = 0; y < BOARD_ROWS; y++) {
                for (let x = 0; x < BOARD_COLS; x++) {
                    const piece = board[y][x];
                    if (piece && piece.color === color) {
                        const legalPieceMoves = getLegalMoves(piece, board);
                        legalPieceMoves.forEach(move => {
                            moves.push({ piece, toX: move.toX, toY: move.toY, target: board[move.toY][move.toX] });
                        });
                    }
                }
            }
            return moves;
        }

        // --- 事件監聽 ---
        boardEl.addEventListener('click', handleBoardClick);
        window.addEventListener('resize', renderBoard); 
        
        restartBtn.addEventListener('click', () => {
            restartConfirmModal.classList.add('show');
        });
        
        undoBtn.addEventListener('click', handleUndo);

        victoryModal.addEventListener('click', () => victoryModal.classList.remove('show'));
        defeatModal.addEventListener('click', () => {
            defeatModal.classList.remove('show');
            initGame();
        });

        confirmYesBtn.addEventListener('click', () => {
            if (pendingMove) {
                movePiece(pendingMove.piece, pendingMove.toX, pendingMove.toY);
                pendingMove = null;
            }
            confirmModal.classList.remove('show');
        });
        confirmNoBtn.addEventListener('click', () => {
            pendingMove = null;
            selectPiece(selectedPiece);
            confirmModal.classList.remove('show');
        });
        
        undoYesBtn.addEventListener('click', () => {
            executeUndo();
        });
        undoNoBtn.addEventListener('click', () => {
            undoModal.classList.remove('show');
        });
        
        restartYesBtn.addEventListener('click', () => {
            restartConfirmModal.classList.remove('show');
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                Tone.start().then(initGame);
            } else {
                initGame();
            }
        });
        restartNoBtn.addEventListener('click', () => {
            restartConfirmModal.classList.remove('show');
        });

        // --- 遊戲啟動 ---
        setupSounds();
        initGame();
    </script>

</body>
</html>
